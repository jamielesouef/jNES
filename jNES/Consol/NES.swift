//
//  NES.swift
//  SwiftNES
//
//  Created by Jamie Le Souef on 17/4/2024.
//

import Foundation
import Combine

let game_code: [UInt8] = [
  0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02,
  0x85, 0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9,
  0x0f, 0x85, 0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85,
  0x00, 0xa5, 0xfe, 0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20,
  0x8d, 0x06, 0x20, 0xc3, 0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c,
  0x38, 0x06, 0xa5, 0xff, 0xc9, 0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0,
  0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60, 0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85,
  0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0, 0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01,
  0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02, 0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05,
  0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06, 0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00,
  0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07, 0xe6, 0x03, 0xe6, 0x03, 0x20,
  0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06, 0xb5, 0x11, 0xc5, 0x11,
  0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c, 0x35, 0x07, 0x60,
  0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02, 0x4a, 0xb0,
  0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9, 0x20,
  0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
  0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10,
  0xb0, 0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5,
  0x10, 0x29, 0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe,
  0x91, 0x00, 0x60, 0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10,
  0x60, 0xa6, 0xff, 0xea, 0xea, 0xca, 0xd0, 0xfb, 0x60,
];
/*
 fn color(byte: u8) -> Color {
 match byte {
 0 => sdl2::pixels::Color::BLACK,
 1 => sdl2::pixels::Color::WHITE,
 2 | 9 => sdl2::pixels::Color::GREY,
 3 | 10 => sdl2::pixels::Color::RED,
 4 | 11 => sdl2::pixels::Color::GREEN,
 5 | 12 => sdl2::pixels::Color::BLUE,
 6 | 13 => sdl2::pixels::Color::MAGENTA,
 7 | 14 => sdl2::pixels::Color::YELLOW,
 _ => sdl2::pixels::Color::CYAN,
 }
 }
 */

struct NesScreenPixelBufferAdapter: ScreenPixelBufferAdapter {
  private let screen: [NES.Color]
  init(_ screen: [NES.Color]) {
    self.screen = screen
  }
  
  func toPixelBuffer() -> [[PixelData]] {
    var data: [[PixelData]] = []
    var index: Int = 0
    
    for _ in 0..<32 {
      var row: [PixelData] = []
      for _ in 0..<32 {
        row.append(screen[index].pixelData)
        index += 1
      }
      data.append(row)
    }
    
    return data
  }
}


final class NES {
  let bus: Bus
  let cpu: CPU
  let controller: Controller
  
  enum Color: UInt8 {
    case black
    case white
    case grey
    case red
    case green
    case blue
    case magenta
    case yellow
    case cyan
  }
  
  init() throws {
    
    let file = Bundle.main.url(forResource: "snake", withExtension: "nes")!
    let data = try Data(contentsOf: file)
    
    let rom = try Rom(data: [UInt8](data))
    
    self.bus = Bus(rom: rom)
    self.cpu = CPU(bus: bus)
    self.controller = Controller()
  }
  
  private (set) var screen: [Color] = .init(repeating: .black, count: 32 * 3 * 32)
  
  var updateScreen: ((ScreenPixelBufferAdapter) -> Void)?
  
  func powerOn() {
    cpu.reset()
    cpu.run {
      let r = UInt8.random(in: 0...255)
      self.bus.writeMem(at: 0xFE, value: r)
      self.udpateScreenIfRequired()
      return self.controller.state
      
    }
  }
  
  func powerOff() {
    cpu.stop()
  }
}

private extension NES {
  
  func color(from byte:  UInt8) -> Color {
    switch byte {
    case 0 : .black
    case 1 : .white
    case 2 | 9: .grey
    case 3 | 10: .red
    case 4 | 11: .green
    case 5 | 12: .blue
    case 6 | 13: .magenta
    case 7 | 14: .yellow
    default : .cyan
    }
  }
  
  func udpateScreenIfRequired() {
    var screenBuffer: [Color] = .init(repeating: .black, count: 32 * 32)
    for i in 0x0200...0x05FF {
      let byte = cpu.readMem(at: UInt16(i))
      let color = color(from: byte)
      screenBuffer[i - 0x0200] = color
    }
    
    if screenBuffer != screen {
      screen = screenBuffer
      updateScreen?(NesScreenPixelBufferAdapter(screen))
    }
  }
}

extension NES: Controllable {
  func didReceiveButtonUp(button: ControllerButton) {
    controller.didReceiveButtonUp(button: button)
  }
  
  func didReceiveButtonDown(button: ControllerButton) {
    controller.didReceiveButtonDown(button: button)
  }
  
  func didReceiveButtonUp(keyCode: UInt16) {
    controller.didReceiveButtonUp(keyCode: keyCode)
  }
  
  func didReceiveButtonDown(keyCode: UInt16) {
    controller.didReceiveButtonDown(keyCode: keyCode)
  }
}


extension NES.Color {
  var pixelData: PixelData {
    switch self {
    case .black: return PixelData(r: 0, g: 0, b: 0, a: 255)
    case .white: return PixelData(r: 255, g: 255, b: 255, a: 255)
    case .grey: return PixelData(r: 128, g: 128, b: 128, a: 255)
    case .red: return PixelData(r: 255, g: 0, b: 0, a: 255)
    case .green: return PixelData(r: 0, g: 255, b: 0, a: 255)
    case .blue: return PixelData(r: 0, g: 0, b: 255, a: 255)
    case .magenta: return PixelData(r: 255, g: 0, b: 255, a: 255)
    case .yellow: return PixelData(r: 255, g: 255, b: 0, a: 255)
    case .cyan: return PixelData(r: 0, g: 255, b: 255, a: 255)
    }
  }
}

